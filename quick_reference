////////////////////////////////
References, Mutable References, and Borrowing:

    - The & indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times.
    - we have to return the String to the calling function so we can still use the String after the call to calculate_length, because the String was moved into calculate_length.
    - How to modify something we’re borrowing ? We can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

fn main() {

    let mut s = String::from("hello");
    println!("s = {}", s);

    let len = calculate_length(&s);
    println!("The length of '{}' is {}.", s, len);

    {
        change(&mut s);
        println!("s = {}", s);
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    change(&mut s);
    println!("s = {}", s);

}


////////////////////////////////
Match & Enum:

#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    let a = value_in_cents(Coin::Quarter(UsState::Alaska));
    println!("Value {}!", a);
}

State quarter from Alaska!
Value 25!

////////////////////////////////
Shadowing:
let x = x + 1;
let x = x * 2;
println!("The value of x is: {}", x)


/////////////////////////////////
isize and usize: 
types depend on the kind of computer your program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit archit
You should use usize whenever you deal with something related to container size, and u32 and u64 for everything else

/////////////////////////////////
Arrays: 
have a fixed length and type, may be good for iterating

let a = [3; 5];
same as:  let a = [3, 3, 3, 3, 3];


/////////////////////////////////
Expressions:
evaluate to something, Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, {}.

let y = {
    let x = 3;
    x + 1
};
4

/////////////////////////////////
Control FLow:
    let condition = true;
    let number = if condition { 5 } else { 6 };


/////////////////////////////////
Ternary Opereator

let mut count = 0;
if let Coin::Quarter(state) = coin { println!("State quarter from {:?}!", state); } else { count += 1; }


/////////////////////////////////
Stack-Only Data: Copy

let x = 5;
let y = x;

/////////////////////////////////
Ownership: fucntions, return values, and Scope:

fn main() {

    let s = String::from("hello");      // s comes into scope

    takes_ownership(s);                 // s's value moves into the function ... and so is no longer valid here

    let x = 5;                          // x comes into scope

    makes_copy(x);                      // x would move into the function, but i32 is Copy, so it's okay to still use x afterward

    let s1 = gives_ownership();         // gives_ownership moves its return value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into takes_and_gives_back, which also moves its return value into s3

}   // Here, x goes out of scope, then s. But because s's value was moved, nothing special happens.
    // s3 goes out of scope and is dropped. s2 goes out of scope but was moved, so nothing happens. s1 goes out of scope and is dropped.


fn gives_ownership() -> String {             // gives_ownership will move its return value into the function that calls it
    let some_string = String::from("hello"); // some_string comes into scope
    some_string                              // some_string is returned and moves out to the calling function
}


// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into scope
    a_string  // a_string is returned and moves out to the calling function
}


fn takes_ownership(some_string: String) {       // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing memory is freed.


fn makes_copy(some_integer: i32) {              // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.


/////////////////////////////////
Structs & Methods:

// define
struct User { 
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

impl User {
    fn print_user(&self) -> bool{
        println!("ueser={}, email={}",self.username,self.email);
        true
    }
}

// instantiate a mutable struct

let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
let a = user1.print_user();

/////////////////////////////////
Project Structure:

https://stackoverflow.com/questions/57756927/rust-modules-confusion-when-there-is-main-rs-and-lib-rs

/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
