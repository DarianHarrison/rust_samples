#### Unsafe Rust #### 

To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code.
The unsafe keyword gives you access to five features that are not checked by the compiler for memory safety.

- Dereference a raw pointer
- Call an unsafe function or method
- Access or modify a mutable static variable
- Implement an unsafe trait
- Access fields of unions

Suggestion: Keep unsafe blocks small; you’ll be thankful later when you investigate memory bugs.

------------------------------------

1. Dereference a raw pointer

By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.

Different from references and smart pointers, raw pointers:
	+ Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location
	+ Aren’t guaranteed to point to valid memory
	+ Are allowed to be null
	+ Don’t implement any automatic cleanup

Use Cases: With all of these dangers, why would you ever use raw pointers? 
+ One major use case is when interfacing with C code, 
+ Another case is when building up safe abstractions that the borrow checker doesn’t understand.



2. Call an unsafe function or method

By calling an unsafe function within an unsafe block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.



3. Access or modify a mutable static variable

In Rust, global variables are called static variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.

With mutable data that is globally accessible, it's difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe.

Constants vs Immutable Static Variables:
	+ Values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.
	+ Static variables can be mutable. Accessing and modifying mutable static variables is unsafe.



4. Implement an unsafe trait

A trait is unsafe when at least one of its methods has some invariant that the compiler can't verify

Example:
	If we implement a type that contains a type that is not Send or Sync, such as raw pointers, and we want to mark that type as Send or Sync, we must use unsafe. Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with unsafe.



5. Access fields of unions

A union is similar to a struct, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code.  Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#### Advanced Traits #### 

1. Specifying Placeholder Types in Trait Definitions with Associated Types


- Associated types connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. 
- The implementor of a trait will specify the concrete type to be used in this type’s place for the particular implementation. That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.
- One example of a trait with an associated type is the Iterator trait that the standard library provides.
- With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times.


2. Default Generic Type Parameters and Operator Overloading

- When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is <PlaceholderType=ConcreteType> when declaring the generic type.
- A great example of a situation where this technique is useful is with operator overloading. Operator overloading is customizing the behavior of an operator (such as +) in particular situations.


3. Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name

- you can have same function names within a trait, jsut make sure to call the full name, ex: E.aggregate(), B.aggregate()
- sample provided in main.rs


4. Using Supertraits to Require One Trait’s Functionality Within Another Trait

- Sometimes, you might need one trait to use another trait’s functionality. In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a supertrait of the trait you’re implementing.


5. Using the Newtype Pattern to Implement External Traits on External Types

- Involves creating a new type in a tuple struct.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#### Advanced Types ####


1. Using the Newtype Pattern for Type Safety and Abstraction

- The newtype pattern is useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value.
- Another use of the newtype pattern is in abstracting away some implementation details of a type: for example, the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality.

2. Creating Type Synonyms with Type Aliases

- Along with the newtype pattern, Rust provides the ability to declare a type alias to give an existing type another name. 
- A type alias can help code be more manageable by reducing the repetition.

3. The Never Type that Never Returns

- Rust has a special type named ! that’s known in type theory lingo as the empty type because it has no values. 
- Type ! can be coerced into any other type.

4. Dynamically Sized Types and the Sized Traits

- Sometimes referred to as DSTs or unsized types, these types let us write code using values whose size we can know only at runtime.
- Example: for Strings, if we will not know how much the input size is; we make the types of s1 and s2 a &str rather than a str
- We can combine str with all kinds of pointers: for example, Box<str> or Rc<str>.
- To work with DSTs, Rust has a particular trait called the Sized trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on Sized to every generic function.



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#### Advanced Functionas and Closures ####

1. Function Pointers

	-	You can also pass regular functions to functions!
	-	This technique is useful when you want to pass a function you’ve already defined rather than defining a new closure. 
	-	Example in function_pointers.rs

2. 	Returning Closures

	-	Closures are represented by traits, which means you can’t return closures directly. 
	-	In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#### Macros ####

We’ve used macros like println!
The term macro refers to a family of features in Rust: declarative macros with macro_rules! and three kinds of procedural macros

- Custom #[derive] macros that specify code added with the derive attribute used on structs and enums
- Attribute-like macros that define custom attributes usable on any item
- Function-like macros that look like function calls but operate on the tokens specified as their argument



